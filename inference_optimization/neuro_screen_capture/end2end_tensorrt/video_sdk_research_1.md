Технический отчет: Интеграция NVIDIA RTX Video Super Resolution (VSR) в конвейер рендеринга C++ с использованием исключительно RGB-фреймбуферов
1. Введение и Архитектурный Контекст
1.1. Эволюция алгоритмов масштабирования в реальном времени
Современная индустрия компьютерной графики переживает фундаментальный сдвиг парадигмы от фиксированных алгоритмов растеризации к гибридным методам, усиленным искусственным интеллектом. Традиционные методы пространственного масштабирования, такие как бикубическая интерполяция или фильтры Ланцоша, достигают своего теоретического предела, неизбежно внося артефакты размытия или звона (ringing) при попытке восстановить высокочастотные детали из низкоразрешенного источника. Технологии временного масштабирования (Temporal Super Resolution), наиболее ярким представителем которых является NVIDIA DLSS (Deep Learning Super Sampling), решили эту проблему за счет использования временной когерентности — накопления данных из предыдущих кадров с использованием векторов движения (Motion Vectors) для корректной репроекции пикселей.
Однако существует значительный класс задач, где интеграция полноценного временного апскейлинга невозможна или нецелесообразна. К таким задачам относятся эмуляторы устаревших консолей, порты старых игр с жестко закодированными конвейерами рендеринга, а также видеоплееры, интегрированные в игровые движки. В этих сценариях разработчик часто не имеет доступа к буферам глубины (Depth Buffers) или векторам движения, либо их извлечение требует несоразмерных трудозатрат по реверс-инжинирингу. Запрос на интеграцию NVIDIA RTX Video Super Resolution (VSR) с использованием только RGB-кадров представляет собой именно такой архитектурный вызов: необходимость получить качество AI-апскейлинга, опираясь исключительно на финальное цветовое изображение (Post-Process Output).
1.2. Позиционирование RTX VSR в экосистеме NVIDIA
NVIDIA RTX Video Super Resolution (VSR) занимает уникальную нишу между классическими методами обработки видео и игровыми технологиями рендеринга. В отличие от DLSS, который требует глубокой интеграции в движок на этапе геометрического прохода (для джиттеринга камеры и генерации векторов скоростей), VSR спроектирован как пост-процессинговый фильтр. Изначально разработанный для улучшения качества потокового видео (YouTube, Twitch, Netflix) в браузерах Chrome и Edge, этот алгоритм был обучен на миллионах пар кадров "низкое разрешение — высокое разрешение" с акцентом на устранение артефактов компрессии (блочность, москитный шум) и восстановление четкости краев.
Важнейшим архитектурным отличием VSR является его способность работать с "чистыми" пиксельными данными без вспомогательной геометрической информации. Хотя алгоритм использует временную информацию (анализируя последовательность кадров для стабильности), он делает это неявным образом, не требуя от хост-приложения явных векторов движения. Это делает его идеальным кандидатом для интеграции в C++ код, где доступен только RGB-буфер (например, текстура с результатом рендеринга игры).
Согласно технической документации 1, VSR выполняется на тензорных ядрах (Tensor Cores) графических процессоров архитектур Ampere (RTX 30-серия) и Ada Lovelace (RTX 40-серия), а также поддерживается на Turing (RTX 20-серия) в последних версиях драйверов. Это обеспечивает высокую производительность, достаточную для обработки видеопотоков и игровых сцен в реальном времени с минимальной задержкой.
1.3. Сравнение SDK: NGX против Maxine против Video Codec SDK
Для разработчика C++ важно различать три основных инструментария, предоставляемых NVIDIA, так как путаница между ними может привести к выбору неверной архитектуры интеграции:
Характеристика
NVIDIA NGX SDK
NVIDIA Maxine Video Effects SDK
NVIDIA Video Codec SDK
Основное назначение
Интеграция AI-функций в графический конвейер (DLSS, VSR)
Эффекты для видеоконференций (удаление фона, шума, апскейл)
Аппаратное кодирование/декодирование видео (NVENC/NVDEC)
Уровень интеграции
Низкоуровневый (DirectX/Vulkan API)
Высокоуровневый, часто требует CUDA-контекст
Работает с битовыми потоками видео
Поддержка RGB
Нативная (через буферные форматы)
Требует конвертации, часто оптимизирован под YUV/NV12
Ориентирован на YUV (NV12, P010)
Применимость к запросу
Высокая (Прямой доступ к VSR)
Средняя (Возможны накладные расходы на CUDA-interop)
Низкая (Только для энкодинга/декодинга файлов)

Как отмечается в обсуждениях сообщества разработчиков и анализе репозиториев 3, "RTX Video SDK" фактически является оберткой (wrapper) над функциональностью NGX. Для максимальной производительности и гибкости в игровом C++ коде рекомендуется использовать прямой доступ через NGX API, так как это позволяет избежать лишних абстракций и дает прямой контроль над ресурсами DirectX 12 или Vulkan.
2. Теоретические основы работы с данными в RTX VSR
2.1. Проблема форматов пикселей: Видео против Игр
Ключевым требованием является использование только RGB кадров.4 Это требование вступает в кажущееся противоречие с природой VSR, обученного на видеоконтенте, который традиционно распространяется в цветовых пространствах YUV (например, YCbCr 4:2:0).
Игровой рендеринг: Обычно оперирует в пространстве RGB (Red, Green, Blue). Данные могут быть линейными (Linear Space) до тональной компрессии или в пространстве sRGB (Gamma 2.2) после неё. Формат хранения в памяти GPU обычно R8G8B8A8_UNORM или R16G16B16A16_FLOAT для HDR.
Видео контент: Использует цветовую субдискретизацию (chroma subsampling), где информация о яркости (Y) хранится в полном разрешении, а цветоразностные компоненты (U, V) — в уменьшенном.
Однако, нейронные сети, лежащие в основе VSR, на входном слое тензоров способны принимать данные в различных форматах, если драйвер обеспечивает соответствующую "распаковку". Согласно документации по NGX и анализу заголовочных файлов 5, API поддерживает формат NVSDK_NGX_Buffer_Format_RGB8UI и NVSDK_NGX_Buffer_Format_RGB32F. Это критически важно: это означает, что нам не нужно вручную конвертировать игровой кадр в YUV (NV12) перед подачей в VSR. Мы можем подавать Texture2D с форматом DXGI_FORMAT_R8G8B8A8_UNORM напрямую, при условии правильной конфигурации параметров создания фичи.
2.2. Нейросетевая модель VSR и "чистые" данные
Поскольку VSR обучена удалять артефакты сжатия (compression artifacts), при подаче на вход "чистого" игрового кадра (который не проходил через видеокодек H.264/HEVC) сеть может попытаться "исправить" детали, которые она сочтет артефактами. Например, жесткие алиасинговые лесенки на краях полигонов могут быть интерпретированы как звон (ringing) или блоки.
Инсайт: Использование VSR для игр — это, по сути, эксплуатация его возможностей супер-разрешения (Super Resolution), при этом возможности деблокинг-фильтрации (Deblocking) могут работать как своеобразный сглаживающий фильтр (Anti-Aliasing). Это может привести к визуально приятному, "кинематографичному" изображению, но потенциально может снизить микроконтраст текстур высокого разрешения. Поэтому важно предоставлять VSR данные после этапа тональной компрессии (Tone Mapping), но, возможно, до наложения пользовательского интерфейса (UI), чтобы текст не подвергался ненужной нейросетевой обработке, которая может исказить шрифты.
2.3. Механизм работы без векторов движения
В отличие от DLSS, который требует от движка игры предоставления буфера векторов движения для расчета того, куда сместился каждый пиксель, VSR работает "вслепую" относительно геометрии сцены. Он полагается на внутреннюю память (hidden state) рекуррентной или сверточной архитектуры сети для анализа оптического потока (Optical Flow) между кадрами самостоятельно, либо (в более простых версиях модели) работает как покадровый апскейлер с высокой временной стабильностью. Для C++ интеграции это означает радикальное упрощение интерфейса: EvaluateFeature будет вызываться только с указателями на входную и выходную текстуры, а параметры MotionVectors, Depth и Exposure будут передаваться как nullptr.6
3. Подготовка окружения и требования к системе
Перед началом написания кода необходимо убедиться в соответствии среды разработки и целевой платформы требованиям SDK.
3.1. Аппаратные и программные требования
Графический процессор:
Рекомендуется: NVIDIA GeForce RTX 30-й или 40-й серии (архитектуры Ampere, Ada Lovelace).
Минимально: GeForce RTX 20-й серии (Turing). Поддержка на Turing была добавлена позже и требует свежих драйверов.
Внимание: На картах серии GTX (10-я и 16-я серии) VSR работать не будет, так как он требует тензорных ядер.1 В отличие от некоторых шейдерных апскейлеров (FSR, NIS), VSR — это аппаратное ускорение AI.
Драйвер:
Минимальная версия: 530.xx.
Рекомендуемая версия: 550.xx и выше (для поддержки последних моделей VSR 1.5 и RTX Video HDR).8
ОС: Windows 10 (Build 2004 или новее) или Windows 11. 64-бит обязательно.
3.2. Получение SDK
Для интеграции нам понадобятся заголовочные файлы и библиотеки NGX. Официально они распространяются через NVIDIA Developer Program.
Скачайте NVIDIA NGX SDK или RTX Video SDK с портала разработчика.1
В пакете SDK найдите:
include/nvsdk_ngx.h — основной заголовочный файл.
include/nvsdk_ngx_defs.h — определения параметров.
include/nvsdk_ngx_params.h — макросы.
lib/x64/nvsdk_ngx_s.lib — статическая библиотека загрузчика (loader).
DLL файлы: Для работы VSR необходима библиотека nvngx_dlvsr.dll (Video Super Resolution).10 Обычно она устанавливается вместе с драйвером в системные папки, но для локальной отладки может потребоваться её наличие в папке с исполняемым файлом.
3.3. Настройка проекта Visual Studio (C++)
Добавьте путь к include в Additional Include Directories.
Добавьте путь к lib/x64 в Additional Library Directories.
Добавьте nvsdk_ngx_s.lib в Additional Dependencies.
Убедитесь, что проект компилируется под архитектуру x64.
Определите макрос препроцессора для выбранного графического API, например NGX_ENABLE_D3D12 для DirectX 12 или NGX_ENABLE_VULKAN для Vulkan.
4. Архитектура интеграции в C++ (DirectX 12)
В этом разделе мы подробно разберем пошаговую реализацию. Мы выберем DirectX 12 как наиболее современный и явный API, дающий полный контроль над ресурсами, что критично для эффективной интеграции AI-моделей.
4.1. Инициализация NGX контекста
Первым шагом является инициализация системы NGX. Это связывает ваше приложение с драйвером NVIDIA и проверяет совместимость железа.

C++


#include <d3d12.h>
#include "nvsdk_ngx.h"
#include "nvsdk_ngx_helpers.h" // Полезные макросы

// Глобальные переменные или члены класса рендерера
NVSDK_NGX_Parameter* g_pNgxParameters = nullptr;
NVSDK_NGX_Handle* g_pNgxVSRHandle = nullptr;
const unsigned long long MY_PROJECT_ID = 123456789; // Используйте ID от NVIDIA или произвольный для тестов

bool InitNGX(ID3D12Device* pDevice, const wchar_t* pLogDir)
{
    // 1. Инициализация NGX с привязкой к D3D12 устройству
    // Параметр L"./" указывает путь, где искать DLL (если нужны локальные).
    // NVSDK_NGX_Version_API проверяет совместимость версий заголовков и драйвера.
    NVSDK_NGX_Result result = NVSDK_NGX_D3D12_Init(
        MY_PROJECT_ID,
        L"./", 
        pDevice
    );

    if (NVSDK_NGX_FAILED(result))
    {
        // Логирование ошибки: Скорее всего, драйвер устарел или карта не RTX.
        return false;
    }

    // 2. Получение интерфейса параметров
    // Этот объект используется для настройки создания фич и передачи параметров при выполнении.
    result = NVSDK_NGX_D3D12_GetCapabilityParameters(&g_pNgxParameters);
    if (NVSDK_NGX_FAILED(result))
    {
        NVSDK_NGX_D3D12_Shutdown();
        return false;
    }

    return true;
}


Важное замечание: Функция NVSDK_NGX_D3D12_Init выполняет неявную проверку подписи драйвера и библиотек. В режиме разработки может потребоваться включение режима отладки, но для релизных драйверов стандартный вызов должен работать стабильно.
4.2. Создание "Фичи" (Feature Creation) для VSR
Здесь мы сталкиваемся с необходимостью правильно сконфигурировать VSR для работы с RGB. В стандартном DLSS мы создаем фичу NVSDK_NGX_Feature_SuperSampling. Для VSR мы должны использовать идентификатор фичи NVSDK_NGX_Feature_VideoSuperResolution.11
Если в вашем заголовочном файле nvsdk_ngx_defs.h нет прямого определения NVSDK_NGX_Feature_VideoSuperResolution (что возможно в старых версиях SDK), необходимо обновить SDK или использовать соответствующий идентификатор из актуальной документации.

C++


bool CreateVSRFeature(ID3D12CommandQueue* pCommandQueue)
{
    // Проверка поддержки VSR на данной системе
    int isVSRSupported = 0;
    NVSDK_NGX_Parameter_GetI(g_pNgxParameters, NVSDK_NGX_Parameter_VideoSuperResolution_Available, &isVSRSupported);
    if (!isVSRSupported)
    {
        // VSR не поддерживается (например, выключен в панели управления NVIDIA или старый GPU)
        return false;
    }

    // Настройка параметров создания
    // Для VSR ключевыми являются ширина и высота ввода/вывода, но часто они задаются при выполнении.
    // Однако создание хендла (Handle) требует инициализации внутренних структур.
    
    // ВАЖНО: Определяем флаги. Для чистого RGB нам не нужны флаги IsHDR (если контент SDR).
    // Если вы хотите апскейлить HDR контент, добавьте NVSDK_NGX_DLSS_Feature_Flags_IsHDR.
    NVSDK_NGX_DLSS_Create_Params createParams = {};
    createParams.Feature.InWidth = inputWidth;   // Например, 1920
    createParams.Feature.InHeight = inputHeight; // Например, 1080
    createParams.Feature.InTargetWidth = outputWidth; // Например, 3840
    createParams.Feature.InTargetHeight = outputHeight; // Например, 2160
    createParams.Feature.InPerfQualityValue = NVSDK_NGX_PerfQuality_Value_MaxQuality; // Максимальное качество

    // Создание фичи. Обратите внимание на ID фичи.
    NVSDK_NGX_Result result = NVSDK_NGX_D3D12_CreateFeature(
        pCommandQueue,
        NVSDK_NGX_Feature_VideoSuperResolution, // ID для VSR
        g_pNgxParameters,
        &g_pNgxVSRHandle
    );

    return NVSDK_NGX_SUCCEED(result);
}


4.3. Управление ресурсами и Барьеры (Resource Barriers)
Одной из самых частых проблем при интеграции NGX в DX12 является некорректное состояние ресурсов. NGX ожидает, что входные текстуры будут в состоянии, доступном для чтения шейдером, а выходные — в состоянии, доступном для записи (Unordered Access).
Входной RGB кадр: Должен быть в состоянии D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE или D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE.
Выходной кадр: Должен быть в состоянии D3D12_RESOURCE_STATE_UNORDERED_ACCESS (UAV), так как нейросеть будет писать в него результат через Compute Shader.
4.4. Цикл отрисовки: Выполнение VSR
В каждом кадре игрового цикла, после того как основной рендеринг завершен, но перед Present, мы вызываем EvaluateFeature.

C++


void ExecuteVSR(
    ID3D12GraphicsCommandList* pCmdList,
    ID3D12Resource* pInputTexture,  // Ваша RGB текстура игры (1080p)
    ID3D12Resource* pOutputTexture  // Целевая текстура (4K)
)
{
    // 1. Барьеры переходов состояний ресурсов
    D3D12_RESOURCE_BARRIER barriers;
    
    // Переводим вход из RenderTarget (если мы только что в него рисовали) в Shader Resource
    barriers = CD3DX12_RESOURCE_BARRIER::Transition(
        pInputTexture,
        D3D12_RESOURCE_STATE_RENDER_TARGET, 
        D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE
    );
    
    // Переводим выход в UAV для записи результата
    barriers = CD3DX12_RESOURCE_BARRIER::Transition(
        pOutputTexture,
        D3D12_RESOURCE_STATE_COMMON, // Или другое начальное состояние
        D3D12_RESOURCE_STATE_UNORDERED_ACCESS
    );
    
    pCmdList->ResourceBarrier(2, barriers);

    // 2. Настройка параметров для текущего кадра
    // Явно указываем, что векторов движения и глубины нет (nullptr).
    // Это критически важно для удовлетворения требования "только RGB".
    
    // Подготовка списка входных ресурсов
    // В зависимости от версии SDK, интерфейс EvaluateFeature может меняться.
    // Часто используется хелпер EvaluateFeature_C или ручная установка параметров.
    
    NVSDK_NGX_Result result = NVSDK_NGX_D3D12_EvaluateFeature(
        pCmdList,
        g_pNgxVSRHandle,
        g_pNgxParameters,
        nullptr // Callback не нужен
    );
    
    // ВАЖНО: Если EvaluateFeature не принимает текстуры напрямую аргументами,
    // их нужно предварительно "привязать" через SetResource к g_pNgxParameters.
    // NVSDK_NGX_Parameter_SetResource(g_pNgxParameters, NVSDK_NGX_Parameter_Color, pInputTexture);
    // NVSDK_NGX_Parameter_SetResource(g_pNgxParameters, NVSDK_NGX_Parameter_Output, pOutputTexture);
    
    // 3. Восстановление состояний ресурсов (если нужно для дальнейшего использования, например UI или Present)
    D3D12_RESOURCE_BARRIER restoreBarriers;
    restoreBarriers = CD3DX12_RESOURCE_BARRIER::Transition(
        pOutputTexture,
        D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
        D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE | D3D12_RESOURCE_STATE_PRESENT
    );
    pCmdList->ResourceBarrier(1, restoreBarriers);
}


5. Углубленный анализ спецификаций данных
Для успешной реализации требования "RGB и ничего более" необходимо понимать, как именно NGX интерпретирует пиксельные данные.
5.1. Формат поверхности (Surface Format)
Согласно документации Maxine и NGX 4, фильтры супер-разрешения поддерживают планарные форматы (BGR planar) или упакованные (RGBA packed). В контексте DX12 и игрового рендеринга мы почти всегда работаем с упакованными форматами.
Рекомендуемый формат: DXGI_FORMAT_R8G8B8A8_UNORM. Это стандартный 32-битный формат (8 бит на канал).
Интерпретация данных: VSR ожидает данные в диапазоне [0.0, 1.0]. В формате UNORM это происходит автоматически. Если вы используете формат FLOAT (HDR), убедитесь, что значения нормализованы или используйте HDR-вариант VSR, который корректно обрабатывает значения > 1.0.
5.2. Цветовое пространство (Color Space)
VSR чувствителен к гамма-коррекции.
Если подать линейный RGB (Linear RGB), результат может быть слишком темным или контрастным, так как сеть ожидает перцептуально равномерное распределение яркости (гамма 2.2 или sRGB), характерное для видео.
Рекомендация: Если ваш игровой движок работает в линейном пространстве, выполните проход Tone Mapping и Gamma Correction перед подачей кадра в VSR. Выход VSR будет уже в sRGB (или Rec.709), готовый к отображению на мониторе.
5.3. Обработка Alpha-канала
В запросе указано "RGB кадры". В DX12 текстуры часто имеют Alpha-канал (RGBA). VSR, как правило, игнорирует альфа-канал при обработке цвета, но содержимое альфа-канала в выходной текстуре может быть неопределенным или сброшенным (например, в 1.0).
Риск: Если вы планируете накладывать UI после VSR, используя альфа-блендинг с результатом VSR, убедитесь, что VSR не "испортил" альфа-канал, если он вам нужен для композитинга. Лучшая практика — использовать VSR для фона (игры), а UI рендерить отдельным проходом поверх уже апскейленного изображения в нативном разрешении 4K.
6. Производительность и оптимизация
Интеграция VSR добавляет фиксированную стоимость к времени кадра. Понимание этой стоимости критично для real-time приложений.
6.1. Задержка (Latency)
Согласно тестам и документации 10, выполнение VSR занимает "несколько миллисекунд" на кадр.
На RTX 4070 апскейл 1080p -> 4K может занимать порядка 2-4 мс.
Это больше, чем простой билинейный апскейл (0.1 мс), но сопоставимо с тяжелыми пост-эффектами.
Для 60 FPS (бюджет 16.6 мс) это приемлемо. Для 144 FPS это может стать узким местом.
6.2. Потребление памяти (VRAM)
VSR требует выделения внутренней памяти (Scratch Buffer) для тензоров. Размер этого буфера зависит от входного разрешения. Для 4K выхода это может составлять сотни мегабайт. В C++ коде можно запросить необходимый размер буфера через NVSDK_NGX_D3D12_GetScratchBufferSize и управлять его выделением, если требуется жесткий контроль памяти, хотя обычно NGX управляет этим автоматически.
6.3. Асинхронные вычисления (Async Compute)
В DX12 вы можете запустить VSR на очереди вычислений (Compute Queue), параллельно с рендерингом UI или физикой следующего кадра.
Сложность: Требует тщательной синхронизации через Fences.
Выгода: Может скрыть часть задержки VSR.
Однако, поскольку VSR зависит от завершенного кадра, возможности перекрытия ограничены. Простейшая реализация — синхронный вызов в Graphics Queue перед Present.
7. Сравнение с альтернативами для задачи "Только RGB"
Чтобы подтвердить правильность выбора VSR, сравним его с другими решениями, доступными в C++ без векторов движения:
Технология
Тип
Входные данные
Качество
Артефакты
NVIDIA VSR
AI (Tensor Cores)
RGB (Video-like)
Высокое (реконструкция краев)
Возможно сглаживание текстур
FSR 1.0 / CAS
Пространственный (Shader)
RGB
Среднее (шарпенинг)
Звон, алиасинг на движении
NIS (Image Scaling)
Пространственный (Shader)
RGB
Среднее
Похоже на FSR 1.0
Bicubic / Lanczos
Традиционный
RGB
Низкое
Размытие

Вывод: Для задачи получения "4K изображения из 1080p источника" без доступа к движку (векторам движения), VSR является наилучшим решением по качеству, так как использует "галлюцинаторные" способности AI для восстановления деталей, которые простые математические фильтры (FSR 1.0) восстановить не могут.
8. Поиск и устранение неисправностей (Troubleshooting)
При интеграции вы можете столкнуться с рядом специфических ошибок NGX.
8.1. NVSDK_NGX_Result_FAIL_FEATURE_NOT_SUPPORTED
Это самая частая ошибка.14 Возможные причины:
Hardware: Запуск на GTX 1080 или AMD карте. Требуется RTX.
Библиотеки: Отсутствует nvngx_dlvsr.dll в папке приложения или в путях поиска. Убедитесь, что DLL скопирована в Release папку.
Подпись: Если вы используете девелоперские версии DLL, драйвер может блокировать их загрузку без включенного режима отладки.
8.2. Черный экран или артефакты цветов
Барьеры: Проверьте D3D12_RESOURCE_BARRIER. Если текстура не переведена в состояние UNORDERED_ACCESS перед записью, результат будет неопределен.
Формат: Если картинка выглядит "кислотной" или неправильной по гамме, проверьте соответствие форматов (UNORM vs FLOAT) и цветовых пространств. VSR ожидает sRGB.
9. Заключение
Интеграция NVIDIA RTX Video Super Resolution в C++ приложение с использованием только RGB кадров — это не только выполнимая, но и архитектурно обоснованная задача. В отличие от DLSS, требующего глубокой интеграции в движок, VSR позволяет трактовать выходной буфер игры как видеопоток, применяя к нему мощные алгоритмы реконструкции на базе глубокого обучения.
Ключ к успеху лежит в правильном использовании NGX API (а не высокоуровневых SDK типа Maxine, если требуется низкоуровневый контроль), корректном управлении ресурсами DirectX 12 и понимании того, что входные данные должны быть подготовлены в цветовом пространстве, ожидаемом видео-ориентированной моделью (sRGB/Gamma 2.2). Следуя представленному руководству, разработчик может значительно повысить визуальное качество старых игр или приложений с фиксированным разрешением, задействовав аппаратные возможности современных GPU серии RTX.
Список использованных источников (в тексте):
.1
Источники
RTX Video SDK - NVIDIA Developer, дата последнего обращения: февраля 6, 2026, https://developer.nvidia.com/rtx-video-sdk
Enhancing Low-Resolution SDR Video with the NVIDIA RTX Video SDK, дата последнего обращения: февраля 6, 2026, https://developer.nvidia.com/blog/enhancing-low-resolution-sdr-video-with-the-nvidia-rtx-video-sdk/
ngx vsr filter · Issue #605 · rigaya/NVEnc - GitHub, дата последнего обращения: февраля 6, 2026, https://github.com/rigaya/NVEnc/issues/605
Super Resolution — NVIDIA Maxine Video Effects (VFX) SDK User Guide, дата последнего обращения: февраля 6, 2026, https://docs.nvidia.com/maxine/vfx/1.0.0/Filters/SuperResolution.html
Programming Guide - NVIDIA Docs, дата последнего обращения: февраля 6, 2026, https://docs.nvidia.com/ngx/programming-guide/index.html
Using DLSSG without IDXGISwapChain::Present() - DLSS - NVIDIA Developer Forums, дата последнего обращения: февраля 6, 2026, https://forums.developer.nvidia.com/t/using-dlssg-without-idxgiswapchain-present/247260
Guide: How to enable RTX VSR (Video Super Resolution) in VLC media player - Reddit, дата последнего обращения: февраля 6, 2026, https://www.reddit.com/r/VLC/comments/12vfy0l/guide_how_to_enable_rtx_vsr_video_super/
New AI SDKs and Tools Released for NVIDIA Blackwell GeForce RTX 50 Series GPUs, дата последнего обращения: февраля 6, 2026, https://developer.nvidia.com/blog/new-ai-sdks-and-tools-released-for-nvidia-blackwell-geforce-rtx-50-series-gpus/
en-us.sitemap.xml - NVIDIA Developer, дата последнего обращения: февраля 6, 2026, https://developer.nvidia.com/sitemaps/en-us.sitemap.xml
NGX Release 1.0.0 - NVIDIA Docs, дата последнего обращения: февраля 6, 2026, https://docs.nvidia.com/ngx/latest/ngx-release-notes/rel_1-0-0.html
CUDA 10.0 NEW FEATURES & CAPABILITIES - NVIDIA, дата последнего обращения: февраля 6, 2026, https://www.nvidia.com/content/apac/gtc/ja/pdf/2018/2052.pdf
Super Resolution — NVIDIA Maxine Video Effects (VFX) SDK User ..., дата последнего обращения: февраля 6, 2026, https://docs.nvidia.com/maxine/vfx/1.1.0/Filters/SuperResolution.html
Programming Guide - NVIDIA NGX, дата последнего обращения: февраля 6, 2026, https://docs.nvidia.com/ngx/latest/programming-guide/index.html
The last twice I was recording my let's play it only recorded for 1 hr 30 min, then 1 hr 50 min. Of course, I didn't realise until after I finished playing. Any ideas why this could be happening? : r/obs - Reddit, дата последнего обращения: февраля 6, 2026, https://www.reddit.com/r/obs/comments/1j2m3pw/the_last_twice_i_was_recording_my_lets_play_it/
OBS Reply buffer stops recording after some time, дата последнего обращения: февраля 6, 2026, https://obsproject.com/forum/threads/obs-reply-buffer-stops-recording-after-some-time.170471/
DLSS fails to enable for D3D11 / NGX DLSS Context cannot run - NVIDIA Developer Forums, дата последнего обращения: февраля 6, 2026, https://forums.developer.nvidia.com/t/dlss-fails-to-enable-for-d3d11-ngx-dlss-context-cannot-run/307531
