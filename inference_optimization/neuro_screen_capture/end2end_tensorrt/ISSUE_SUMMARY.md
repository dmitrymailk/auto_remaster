# Отчет об ошибках и их исправлении

Были выявлены и исправлены две критические ошибки в пайплайне C++ TensorRT, которые приводили к некорректной работе модели (темное изображение или отсутствие эффекта от UNet).

## 1. Неверная размерность латентного пространства (Latent Dimensions)

**Проблема:**
В файле `config.h` константа `LATENT_CHANNELS` была установлена в значение `4`. Это значение использовалось для предыдущих версий VAE, но для текущей модели Flux Tiny VAE, которая работает в связке с UNet, требовалось значение `128` (чтобы после конкатенации с "шумом" получить 256 каналов на входе UNet).

**Симптомы:**
UNet получал на вход тензор с неправильным количеством каналов (8 вместо 256), что приводило к совершенно неверным предсказаниям или "черному ящику".

**Исправление:**
В `config.h`:
```cpp
// Было:
#define LATENT_CHANNELS 4

// Стало:
#define LATENT_CHANNELS 128
```

## 2. Ошибка в логике шага планировщика (Scheduler Step Logic)

**Проблема:**
В файле `cuda_utils.cu`, в функции `scheduler_step_kernel`, формула обновления латентов была реализована с ошибкой знака для члена `velocity * dt`.
Поскольку `dt` (разница между sigma следующего и текущего шага) уже является отрицательным числом (мы идем от зашумленного к чистому изображению), дополнительное отрицание приводило к сложению, а не вычитанию предсказанного шума/скорости.

**Симптомы:**
Модель вместо того, чтобы "очищать" изображение, добавляла к нему предсказанный шум в неверном направлении, что могло приводить к визуально "никакому" результату или артефактам, так как процесс диффузии шел в обратную сторону или хаотично.

**Исправление:**
В `cuda_utils.cu`:
```cpp
// Было:
float dt = sigma_next - sigma; 
s = s + velocity * -dt; // Ошибка: двойное отрицание

// Стало:
float dt = sigma_next - sigma; 
s = s + velocity * dt; // Правильно: dt уже отрицательный
```

После этих исправлений и пересборки (`build.ps1`) пайплайн должен работать корректно и соответствовать результатам Python версии.
