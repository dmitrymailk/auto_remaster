Полное техническое руководство: Интеграция NVIDIA RTX Video Super Resolution в графический конвейер C++ для обработки RGB-кадров
1. Введение и постановка задачи
В современной индустрии компьютерной графики технологии масштабирования изображения (апскейлинга) заняли центральное место в вопросах оптимизации производительности и повышения визуального качества. Традиционные методы, такие как бикубическая интерполяция или пространственные фильтры (например, NVIDIA Image Scaling или AMD FSR 1.0), хотя и просты в реализации, часто страдают от артефактов, таких как размытие текстур или мерцание на высокочастотных деталях. С появлением тензорных ядер в графических процессорах NVIDIA серий RTX 20, 30 и 40, индустрия получила доступ к алгоритмам на базе искусственного интеллекта, способным восстанавливать детали с недостижимой ранее точностью.
Основной фокус разработчиков игр сместился на технологии, требующие глубокой интеграции в движок, такие как DLSS (Deep Learning Super Sampling). DLSS использует векторы движения (motion vectors), буфер глубины (depth buffer) и данные о джиттере камеры для временной реконструкции кадра.1 Однако существует значительный класс задач, где такая глубокая интеграция невозможна или нецелесообразна. К ним относятся эмуляторы старых консолей, постобработка видеопотоков, игры на проприетарных движках без доступа к внутренним буферам, а также сценарии, описанные в текущем запросе: необходимость апскейлинга, имея на входе только готовые RGB-кадры.
В ответ на потребность улучшения качества потокового видео NVIDIA представила технологию RTX Video Super Resolution (VSR).2 Изначально позиционируемая как решение для браузеров (Chrome, Edge) и видеоплееров (VLC), VSR использует те же аппаратные блоки тензорных ядер, что и DLSS, но обучена работать исключительно с растровым изображением, без вспомогательных геометрических данных. Это делает VSR идеальным кандидатом для реализации задачи "RGB-only" апскейлинга в C++ приложении.
Тем не менее, интеграция VSR в игровой цикл представляет собой нетривиальную инженерную задачу. VSR является частью видео-экосистемы драйвера, а не графического конвейера Direct3D. Она ожидает входные данные в цветовых пространствах YUV (например, NV12 или P010), типичных для видеокодеков, в то время как игровой рендеринг происходит в RGB. Данный отчет представляет собой исчерпывающее руководство по преодолению этих архитектурных барьеров, детально описывая методы взаимодействия с недокументированными расширениями драйвера NVIDIA, управление цветовыми преобразованиями и синхронизацию асинхронных очередей видеопроцессора.



2. Теоретические основы и аппаратная архитектура
Для успешной реализации VSR в коде C++ необходимо глубокое понимание того, как именно NVIDIA реализует эту технологию на аппаратном уровне и чем она отличается от других методов апскейлинга, доступных разработчику.
2.1. Природа RTX Video Super Resolution
Технология RTX VSR, анонсированная на CES 2023, представляет собой алгоритм глубокого обучения, выполняемый на тензорных ядрах GPU.3 Модель нейронной сети обучена на миллионах пар изображений низкого и высокого разрешения, что позволяет ей не просто интерполировать пиксели, но и галлюцинировать (восстанавливать) высокочастотные детали, такие как текстуры волос, травы или текста, которые были утрачены при даунскейлинге или компрессии.
Важнейшей особенностью VSR является то, что она спроектирована для работы с видеопотоком. Это означает, что алгоритм включает в себя механизмы подавления артефактов сжатия (blockiness reduction) и временной стабильности, хотя и не использует векторы движения движка. Входным форматом для VSR, как правило, является YUV 4:2:0 (формат NV12 в терминологии DirectX), поскольку именно в этом формате декодируется большинство видеоконтента (H.264, HEVC, AV1).4
Это создает фундаментальный барьер для интеграции в игры: игровой движок генерирует кадры в формате RGB (например, R8G8B8A8_UNORM). Прямая подача RGB-буфера в API видеопроцессора NVIDIA для VSR невозможна или неэффективна, так как нейросеть ожидает разделения яркостной (Luma) и цветоразностных (Chroma) компонент. Следовательно, интеграция VSR неизбежно требует этапа предварительной конвертации цветового пространства, что вносит дополнительные вычислительные затраты.
2.2. Аппаратная совместимость и требования к драйверу
Реализация VSR жестко привязана к аппаратным возможностям конкретных поколений GPU. Согласно документации и тестам сообщества, поддержка обеспечивается для видеокарт серий GeForce RTX 30 (Ampere) и RTX 40 (Ada Lovelace).5 Позже поддержка была расширена на серию RTX 20 (Turing) 6, однако эффективность работы на старых тензорных ядрах может отличаться.
С точки зрения программного обеспечения, критическим является наличие драйвера Game Ready версии 530.xx или выше, где впервые была внедрена поддержка VSR.7 Для разработчика на C++ это означает, что код должен включать проверки версии драйвера и архитектуры GPU перед попыткой инициализации VSR, чтобы избежать сбоев на несовместимом оборудовании.
2.3. Альтернативы: VSR против NIS и Maxine
При задаче апскейлинга "только RGB" разработчик сталкивается с выбором между тремя технологиями, каждая из которых имеет свои плюсы и минусы:
NVIDIA Image Scaling (NIS): Это пространственный апскейлер, реализованный как шейдер.9
Преимущества: Чрезвычайно быстрая работа (микросекунды), простая интеграция (просто добавление HLSL шейдера), работа на любом GPU (даже не NVIDIA).
Недостатки: Качество изображения значительно уступает методам на базе ИИ. NIS просто повышает резкость и интерполирует, что приводит к появлению "звона" (ringing artifacts) и алиасингу.
NVIDIA Maxine (Video Effects SDK): Это официальный SDK для наложения ИИ-эффектов.11
Преимущества: Документированный C API, прямая поддержка RGB-буферов.
Недостатки: Требует распространения тяжелых DLL и моделей вместе с приложением (сотни мегабайт), имеет высокую задержку (до 3-5 мс на кадр), требует контекста CUDA, что усложняет интероп с DirectX.
RTX VSR (через драйвер/Video API):
Преимущества: Высочайшее качество для видеоконтента, использование выделенного блока Video Engine, отсутствие необходимости распространять модели (они в драйвере).
Недостатки: Сложная, недокументированная интеграция через расширения DirectX Video API, жесткое требование конвертации в NV12.
Исходя из запроса пользователя на "интеграцию RTX VSR", мы сосредоточимся на третьем варианте, как наиболее соответствующем терминологии запроса, но также рассмотрим вариант с Maxine как более документированную альтернативу, обеспечивающую схожий результат.
3. Архитектура интеграции: Преодоление барьера RGB-NV12
Центральной проблемой при интеграции VSR в игровой движок является несовпадение форматов данных. Игровой движок (Unreal, Unity или кастомный C++ движок) завершает рендеринг кадра, записывая результат в текстуру SwapChain или промежуточный Render Target. Формат этой текстуры — RGB (обычно DXGI_FORMAT_R8G8B8A8_UNORM или R10G10B10A2_UNORM для HDR).
RTX VSR, будучи частью конвейера обработки видео, ожидает на входе данные в формате YUV 4:2:0 (NV12). Это связано с тем, что VSR обучалась на видеоданных, где цветовая информация сжата (subsampled) для экономии пропускной способности. Подача RGB данных напрямую не приведет к активации алгоритма VSR, так как драйвер просто не распознает этот формат как валидный для видеообработки.
3.1. Математика преобразования цветов
Для корректной работы VSR необходимо реализовать два этапа конвертации:
RGB -> NV12: Перед подачей в VSR.
NV12 -> RGB: После обработки VSR, для отображения на мониторе.
Стандартное преобразование (по стандарту BT.709 для HD/FHD контента) выглядит следующим образом:



Важно отметить, что формат NV12 подразумевает субдискретизацию цветности. На каждые 4 пикселя яркости (2x2 блок Y) приходится только одна пара значений U и V. Это означает, что при конвертации RGB игры в NV12 вы безвозвратно теряете 75% цветовой информации. Для большинства сцен это незаметно глазу, но для мелкого цветного текста (UI) или высококонтрастных элементов HUD это может привести к артефактам "цветового кровотечения" (color bleeding).
3.2. Выбор цветового пространства
При реализации конвертации критически важно учитывать гамма-коррекцию. Игровые текстуры часто находятся в линейном пространстве (Linear Space) или sRGB. Видеостандарты предполагают определенную передаточную функцию (OETF). Если подать линейные данные RGB в конвертер NV12, ожидающий гамма-корректированный сигнал, результат VSR будет некорректным (слишком темным или светлым), а работа нейросети — неоптимальной, так как она обучалась на гамма-корректированных видео. Рекомендуется преобразовывать линейный RGB в sRGB или Gamma 2.2 перед конвертацией в NV12.
4. Метод А: Интеграция через расширения Direct3D Video API («True VSR»)
Этот метод позволяет задействовать именно ту технологию VSR, которая работает в браузерах Chrome и Edge. Она базируется на использовании скрытых (private) интерфейсов драйвера NVIDIA, доступных через стандартный механизм расширений ID3D11VideoContext::VideoProcessorSetStreamExtension. Анализ исходного кода проектов с открытым исходным кодом, таких как mpv 12 и Moonlight 13, позволяет восстановить этот протокол.
4.1. Инициализация Direct3D 11 Video Context
Даже если ваш движок использует Direct3D 12, для работы с видео часто удобнее использовать Direct3D 11 через механизм D3D11On12, так как API видеопроцессора в D3D11 более зрелый и лучше исследован сообществом в контексте VSR. Впрочем, современные драйверы поддерживают VSR и в D3D12. Рассмотрим базовую структуру на D3D11.
Первым шагом является получение интерфейсов ID3D11VideoDevice и ID3D11VideoContext из вашего устройства D3D11.

C++


ID3D11Device* device; // Ваше устройство
ID3D11DeviceContext* context; // Ваш контекст

ID3D11VideoDevice* videoDevice = nullptr;
ID3D11VideoContext* videoContext = nullptr;

// QueryInterface для получения видео-интерфейсов
HRESULT hr = device->QueryInterface(__uuidof(ID3D11VideoDevice), (void**)&videoDevice);
hr = context->QueryInterface(__uuidof(ID3D11VideoContext), (void**)&videoContext);


Далее необходимо создать перечислитель видеопроцессоров (VideoProcessorEnumerator) и сам видеопроцессор. При создании D3D11_VIDEO_PROCESSOR_CONTENT_DESC важно указать правильные размеры входного (игры) и выходного (экрана) изображения.

C++


D3D11_VIDEO_PROCESSOR_CONTENT_DESC contentDesc = {};
contentDesc.InputFrameFormat = D3D11_VIDEO_FRAME_FORMAT_PROGRESSIVE;
contentDesc.InputWidth = gameWidth;
contentDesc.InputHeight = gameHeight;
contentDesc.OutputWidth = displayWidth;
contentDesc.OutputHeight = displayHeight;
contentDesc.Usage = D3D11_VIDEO_USAGE_PLAYBACK_NORMAL;

ID3D11VideoProcessorEnumerator* videoEnum = nullptr;
videoDevice->CreateVideoProcessorEnumerator(&contentDesc, &videoEnum);

ID3D11VideoProcessor* videoProcessor = nullptr;
videoDevice->CreateVideoProcessor(videoEnum, 0, &videoProcessor);


4.2. Магия GUID: Активация VSR
Самая сложная часть — заставить драйвер включить VSR. Стандартный API D3D11 не имеет флага D3D11_VIDEO_PROCESSOR_FEATURE_SUPER_RESOLUTION. NVIDIA использует механизм VideoProcessorSetStreamExtension, который принимает GUID и указатель на данные.
Исследования сообщества 12 выявили следующий GUID, отвечающий за интерфейс пост-процессинга NVIDIA (PPE):
GUID: {0xd43ce1b3, 0x1f4b, 0x48ac, {0xba, 0xee, 0xc3, 0xc2, 0x53, 0x75, 0xe6, 0xf7}}
Для активации VSR необходимо передать структуру данных с определенной версией и ID метода.

C++


// Определения (восстановлены из open-source)
const GUID kNvidiaPPEInterfaceGUID = { 0xd43ce1b3, 0x1f4b, 0x48ac, {0xba, 0xee, 0xc3, 0xc2, 0x53, 0x75, 0xe6, 0xf7} };
const UINT kStreamExtensionVersionV1 = 0x1;
const UINT kStreamExtensionMethodSuperResolution = 0x2;

struct NvVsrStreamExtensionInfo {
    UINT version;
    UINT method;
    UINT enable; // 1 = On, 0 = Off
};

// Включение VSR
NvVsrStreamExtensionInfo vsrInfo = {};
vsrInfo.version = kStreamExtensionVersionV1;
vsrInfo.method = kStreamExtensionMethodSuperResolution;
vsrInfo.enable = 1;

// Вызов расширения
hr = videoContext->VideoProcessorSetStreamExtension(
    videoProcessor,
    0, // Stream Index
    &kNvidiaPPEInterfaceGUID,
    sizeof(vsrInfo),
    &vsrInfo
);

if (FAILED(hr)) {
    // Обработка ошибки: VSR не поддерживается драйвером или GPU
}


Этот вызов сообщает драйверу, что для следующей операции VideoProcessorBlt на нулевом потоке следует применить алгоритм Super Resolution.



4.3. Выполнение масштабирования (VideoProcessorBlt)
После настройки расширения выполняется само масштабирование. Здесь происходит переход от вашей входной текстуры (игры) к выходной (экрана).
Подготовка поверхностей:
Создайте входную текстуру ID3D11Texture2D с форматом DXGI_FORMAT_NV12 и флагами D3D11_BIND_RENDER_TARGET | D3D11_BIND_VIDEO_ENCODER.
Создайте выходную текстуру с целевым разрешением (4K).
Запуск Compute Shader:
Запустите шейдер, который читает ваш RGB кадр и записывает данные в NV12 текстуру.
Настройка D3D11_VIDEO_PROCESSOR_STREAM:
Укажите pInputSurface как вашу NV12 текстуру.
Убедитесь, что Enable установлено в TRUE.
Вызов Blit:
C++
hr = videoContext->VideoProcessorBlt(
    videoProcessor,
    outputView, // Output View (обычно целевая текстура NV12 или RGB)
    0,          // Output Frame Index
    1,          // Stream Count
    &stream     // Stream Array
);


Важно отметить, что VideoProcessorBlt может поддерживать запись сразу в RGB, если драйвер это позволяет. Если нет, выходной буфер тоже будет NV12, и потребуется второй проход Compute Shader для конвертации NV12 -> RGB перед отображением в SwapChain.
5. Метод Б: Интеграция через NVIDIA Maxine Video Effects SDK
Если использование недокументированных GUID кажется неприемлемым для стабильного продакшн-кода (так как NVIDIA может изменить их в любой момент), существует официальный, документированный путь — NVIDIA Maxine Video Effects SDK (VFX SDK).11
Maxine SDK предоставляет высокоуровневую абстракцию над алгоритмами AI, включая фильтр "Super Res". Хотя под капотом используются те же тензорные ядра, архитектура вызова отличается: Maxine работает через CUDA.
5.1. Подготовка и инициализация
Загрузка SDK: Необходимо скачать SDK с сайта NVIDIA Developer. Он включает в себя заголовочные файлы, библиотеки (NvVFX.lib) и модели (файлы .nvf).
Настройка CUDA: Поскольку Maxine использует CUDA, вам необходимо инициализировать контекст CUDA и настроить интероперабельность с DirectX (CUDA-D3D11 Interop или CUDA-D3D12 Interop), чтобы передавать текстуры без копирования через CPU.
5.2. Реализация пайплайна Maxine
В отличие от метода с драйвером, Maxine позволяет работать с буферами в формате BGR (Planar или Interleaved).14 Это упрощает задачу, так как исключает необходимость работы с NV12, хотя конвертация из RGBA в BGR Planar (float32) все равно может потребоваться для максимального качества.
Процесс выглядит так:
Создание эффекта:
C++
NvVFX_Handle effectHandle;
NvVFX_CreateEffect(NvVFX_FX_SUPER_RES, &effectHandle);


Загрузка моделей: Необходимо указать путь к директории с моделями через параметр NvVFX_PARAMETER_MODEL_DIR.
Конфигурация буферов:
Используйте структуру NvCVImage для описания входного и выходного буферов.
C++
NvCVImage inputImage, outputImage;
// Заполнение структуры (размеры, формат NVCV_BGR, тип данных NVCV_U8 или NVCV_F32)
// Важно: pixelBuffer должен указывать на память GPU (CUDA pointer)


Установка параметров: Для Super Resolution можно выбрать режим (0 — подавление артефактов, 1 — агрессивное улучшение деталей).11
Запуск (Run):
C++
NvVFX_Run(effectHandle, 0); // Асинхронный вызов


5.3. Сравнение с "True VSR"
Хотя Maxine документирована, она имеет существенный недостаток для игр: вес и зависимости. Вам придется распространять сотни мегабайт моделей вместе с игрой. Метод через драйвер (Метод А) использует модели, уже установленные в системе пользователя вместе с драйвером. Кроме того, Maxine часто обновляется отдельно от драйверов, что может создать "ад зависимостей".
Для задачи "апскейл текущей игры" метод через драйвер (Video API) предпочтительнее с точки зрения удобства пользователя (работает "из коробки"), тогда как Maxine дает больше контроля разработчику.
6. Производительность: Задержка и Энергопотребление
Внедрение VSR в игровой цикл имеет свою цену. В отличие от простых шейдеров, нейросетевая обработка — это тяжелая вычислительная задача.
6.1. Анализ задержки (Latency)
Видеопроцессор в GPU NVIDIA — это отдельный движок, работающий асинхронно по отношению к графической очереди (Graphics Queue).
Overhead передачи данных: Конвертация RGB->NV12 и копирование ресурсов добавляет около 0.1–0.3 мс.
Инференс (Inference): Согласно данным бенчмарков Maxine 16, задержка обработки кадра (Latency) для Super Res составляет:
RTX 4090: ~0.52 мс (весьма быстро).
RTX 3080/3090: ~1.57 мс.
RTX 2060: ~3.5 мс.
Для игры, работающей при 60 FPS (бюджет кадра 16.6 мс), добавление 1.5–3.5 мс является существенным, но допустимым. Однако для 144 Гц (бюджет 6.9 мс) задержка в 3.5 мс "съедает" половину времени кадра. Это делает VSR непригодным для киберспортивных дисциплин, но отличным решением для сюжетных игр, RPG или стратегий.
6.2. Энергопотребление (Power Draw)
Тесты показывают, что использование VSR при просмотре видео может увеличивать потребление GPU на 30–150 Вт в зависимости от карты и разрешения.17 В контексте игры, где GPU уже загружен на 95-99% рендерингом 3D-сцены, включение тензорных ядер может привести к упору в лимит мощности (Power Limit). Это вызовет сброс частот (throttling) основного графического ядра, что парадоксальным образом снизит FPS, несмотря на апскейлинг.
Поэтому VSR рекомендуется использовать в сценариях, где GPU недогружен (например, рендеринг в 1080p на карте уровня 4070 Ti, где боттлнеком является CPU или движок), или же предоставлять пользователю опцию выключения этой функции.



7. Практические рекомендации по реализации (Case Studies)
Анализ реализации VSR в проектах Moonlight 13 и mpv 12 дает ценные уроки для интеграции в C++ игры.
7.1. Управление ресурсами и памятью
В проекте Moonlight разработчики столкнулись с необходимостью перехода на D3D12 для полноценной поддержки всех функций, но VSR работает и на D3D11. Ключевой момент — использование NV12 текстур как "посредников".
Урок 1: Не пытайтесь создавать NV12 текстуру с флагом SHADER_RESOURCE и читать из неё как из обычной текстуры в пиксельном шейдере игры. Чтение YUV текстур требует специального сэмплирования. Проще всего использовать Compute Shader для конвертации "на месте".
Урок 2: VSR всегда включен на "High Quality" в коде Moonlight, игнорируя настройки панели управления, если использовать API напрямую. Однако рекомендуется считывать настройки пользователя или предоставлять свой UI для выбора уровня качества (1-4).
7.2. Проблемы с HDR
Согласно 13 и 12, одновременное использование VSR и HDR может вызывать проблемы (черный экран или некорректные цвета). В SDK Maxine для этого есть отдельный эффект TrueHDR. Если ваша игра поддерживает HDR, рекомендуется либо отключать VSR при включении HDR, либо использовать цепочку: Tone Map to SDR -> VSR Upscale -> Inverse Tone Map (что не идеально), либо ждать полной поддержки HDR в VSR драйверах для всех карт. На данный момент RTX Video HDR (SDR to HDR) и VSR могут работать вместе, но это требует тщательной настройки форматов (P010).
8. Заключение
Интеграция NVIDIA RTX Video Super Resolution в C++ код для апскейлинга игры на базе "чистого RGB" является возможной, но требует выхода за рамки традиционного графического программирования. Вместо привычных пиксельных шейдеров разработчику приходится оперировать понятиями видеопроцессинга: цветовыми пространствами YUV, расширениями драйвера и асинхронными очередями видеодвижка.
Использование недокументированных расширений Direct3D Video API (Метод А) является наиболее эффективным путем, обеспечивающим доступ к той же технологии, что и в браузерах, без лишних зависимостей. Однако оно требует тщательного тестирования совместимости драйверов и реализации шейдеров конвертации цветов. Maxine SDK (Метод Б) предлагает более безопасный, но "тяжелый" путь.
Вне зависимости от выбранного метода, VSR предоставляет уникальную возможность значительно улучшить визуальное качество игр без доступа к внутренним данным движка, оправдывая затраты на интеграцию для проектов, где качество картинки превалирует над максимальной частотой кадров.
Works cited
NVIDIA DLSS - NVIDIA Developer, accessed February 8, 2026, https://developer.nvidia.com/rtx/dlss
RTX Video SDK | NVIDIA Developer, accessed February 8, 2026, https://developer.nvidia.com/rtx-video-sdk
Enhancing Low-Resolution SDR Video with the NVIDIA RTX Video ..., accessed February 8, 2026, https://developer.nvidia.com/blog/enhancing-low-resolution-sdr-video-with-the-nvidia-rtx-video-sdk/
NVIDIA Video Codec SDK, accessed February 8, 2026, https://developer.nvidia.com/video-codec-sdk
How to Turn On Nvidia RTX Video Super Resolution - YouTube, accessed February 8, 2026, https://www.youtube.com/watch?v=D1AqtQl98eE
Game Ready Driver 545.84 FAQ/Discussion : r/nvidia - Reddit, accessed February 8, 2026, https://www.reddit.com/r/nvidia/comments/179y9gc/game_ready_driver_54584_faqdiscussion/
RTX Video Super Resolution no longer working, RTX HDR still works : r/pcmasterrace, accessed February 8, 2026, https://www.reddit.com/r/pcmasterrace/comments/1b0rqpw/rtx_video_super_resolution_no_longer_working_rtx/
Game Ready & Studio Driver 560.81 FAQ/Discussion : r/nvidia - Reddit, accessed February 8, 2026, https://www.reddit.com/r/nvidia/comments/1elhiea/game_ready_studio_driver_56081_faqdiscussion/
Streamline - NVIDIA Developer, accessed February 8, 2026, https://developer.nvidia.com/rtx/streamline
NVIDIAGameWorks/NVIDIAImageScaling: NVIDIA Image Scaling SDK - GitHub, accessed February 8, 2026, https://github.com/NVIDIAGameWorks/NVIDIAImageScaling
Video Effects SDK System Guide - NVIDIA Docs, accessed February 8, 2026, https://docs.nvidia.com/deeplearning/maxine/vfx-sdk-system-guide/index.html
RTX Video Enhancement support · Issue #11390 · mpv-player/mpv - GitHub, accessed February 8, 2026, https://github.com/mpv-player/mpv/issues/11390?timeline_page=1
Add Video Super Resolution for Windows (AMD, Intel and NVIDIA ..., accessed February 8, 2026, https://github.com/moonlight-stream/moonlight-qt/pull/1557
Super Resolution — NVIDIA Maxine Video Effects (VFX) SDK User Guide, accessed February 8, 2026, https://docs.nvidia.com/maxine/vfx/1.1.0/Filters/SuperResolution.html
Video Effects SDK Programming Guide - NVIDIA Docs, accessed February 8, 2026, https://docs.nvidia.com/deeplearning/maxine/vfx-sdk-programming-guide/index.html
Performance Reference — NVIDIA Maxine Video Effects (VFX) SDK User Guide, accessed February 8, 2026, https://docs.nvidia.com/maxine/vfx/WindowsVFXSDK/PerformanceReference.html
NVIDIA RTX Video Super Resolution Tested: Image Quality Comparison & Performance : r/hardware - Reddit, accessed February 8, 2026, https://www.reddit.com/r/hardware/comments/11rfba4/nvidia_rtx_video_super_resolution_tested_image/
